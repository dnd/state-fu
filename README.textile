h1. State-Fu

h2. What is it?

State-Fu is:

 * an unique toolkit for state-oriented programming

 * a rich DSL for describing workflows, rules engines and behaviour

 * something you've probably wanted for a long time but didn't know it

It lets you describe:

 * series of discrete states

 * events which can change the current state

 * rules about when these events can occur

 * behaviours which occur when they do

Other libraries exist for ruby which do some or all of these
things. "What's different about State-Fu?", you may ask.

Those libraries you've played with are toys. They're made of
plastic. State-Fu is forged from a reassuringly dense but
unidentifiable metal which comes only from the rarest of meteorites,
and it ticks when you hold it up to your ear.

State-Fu is elegant, powerful and transparent enough that you can use
it to drive substantial parts of your application, and actually want
to do so.

It is designed as a library for authors, as well as users, of
libraries: State-Fu goes to great lengths to impose very few limits on
your ability to introspect, manipulate and extend the core features.

It is also delightfully elegant and easy to use for simple things:
<pre>
<code>
class Document < ActiveRecord::Base
  include StateFu

  def update_rss
    puts "new feed!"
    # ... do something here
  end

  machine( :status ) do
    state :draft do
      event :publish, :to => :published
    end

    state :published do
      on_entry :update_rss
      requires :author  # a database column
    end

    event :delete, :from => :ALL, :to => :deleted do
      execute :destroy
    end
  end
end

my_doc = Document.new

my_doc.status                          # returns a StateFu::Binding, which lets us access the 'Fu
my_doc.status_state     => 'draft'     # if this wasn't already a database column or attribute, an
                                       # attribute has been created to keep track of the state
my_doc.status.name      => :draft      # the name of the current_state (defaults to the first defined)
my_doc.status.publish!                 # raised =>  StateFu::RequirementError: [:author]
                                       # the author requirement prevented the transition
my_doc.status.name      => :draft      # see? still a draft.
my_doc.author = "Susan"                # so let's satisfy it ...
my_doc.publish!                        # and try again.
"new feed!"                            # aha - our event hook fires!
my_doc.status.name      => :published  # and the state has been updated.
</code>
</pre>

Some of the features which set State-Fu apart are:

 * a lovely, simple and flexible API

 * use an ActiveRecord field for state persistence, or just an
   attribute - or use both, on the same class, for different workflows

 * define any number of workflows on the same object / model, or re-use
   them across multiple classes

 * events can transition from / to any number of states

 * drive application behaviour with a rich set of event hooks

 * define behaviour as methods on your objects, or keep it all in the
   state machine itself

 * guard conditions determine at runtime whether a particular state
   transition can occur, and if not, tell a user what they must do
   to satisfy the requirements

 * transitions can be halted midway, and you can actually determine
   why, and where from

 * use helpers to extend State-Fu to suit your problem domain

 * store arbitrary meta-data on any component of a machine - a simple
   but extremely useful tool for integration

 * design for transparency, introspection and ease of debugging means
   a dynamic, powerful system you can actually use

 * fast, lightweight and useful enough to use in any ruby
   project - works with Rails but does not require it.

State-Fu works with ruby 1.8 and 1.9.
