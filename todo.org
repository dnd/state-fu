# +STARTUP:hidestars
# TODO / DEVELOPMENT NOTES
# Note: most of the value of this kind of list is in the act of
# writing it.

# i.e., don't expect it to be up to date.
==================================================

* Documentation, documentation, documentation: cucumber.
* specs
** move specs into bdd folder & use cuke for API / features
** move towards full & consistent rspec unit tests
** rcov (waiting for 1.9) / heckle / et al
** real-world example machines for cucumber features
** rewrite account example integration spec(s)
** test / spec helpers for testing machines
*** helpers for end-user / developers' spec / test / cuke code
** next_state behaviour in particular needs better documentation
** document all the requirement stuff well with examples

* gem release / script for RubyForge; rubyforge project page

* Deep copy / duplication / serialization

* event hook for reconstituted[_at] ( eg :new )
  huh?

* next_state & next_state! method should be able to take a hash or proc a filter
** hash filter based on .options
** proc filter replaces block; arbitrary filtering
** this allows you to eg define :auto => true on some states and filter just those

* singleton machines & deep copy / clone
** machines for an instance of a class
** new hash in FuSpace
** method bind_clone which binds a deep copy of a machine ( eg for customization on subclasses )
** method customize_machine! which clones & replaces class binding with instance binding
** method custom_machine is analogous to .machine but stores ref in singleton land

* meta
** docs
** manual

* features
** ActiveRecord persistence field
*** define attr() and attr=() methods for activerecord models
*** define at machine definition time ( before instantiation )
*** setter should transition to the named state IF there is only one possible event
*** otherwise an error should be raised

** spec / code for introspection of transitionHalted exceptions during a transition
** configurable event method definitions for object / lathe
** ensure event methods are callable before calling state_fu!
*** use method_missing to call .state_fu! then try again / super?
** more / better logging
** test / improve integration w/ rails logger
** automatic transitions
*** automatic events must be simple (single target)
*** flag events as automatic w/ options[:auto] = true
*** automatically sorted & fired whenever ...
    .state_fu is called? .autofire! is called?

* decisions to make
** should binding keep a ref to the last transition?

====================================================

* Known issues / design decisions
** Machines are not inherited. Is this a bug?
   To make them inheritable we'd be back to needing a Binding
   or some other substantial complexity.
   I don't think it's worth it.
** method definitions for event firing cannot be called on the stateful object before state_fu[!] has been called (which instantiates the methods).
** removed ability to have procs as origin / target states
*** not worth the complexity, too hard to debug in real use, performance
*** can easily add all states as potential candidates, to be screened via requirements

* Wishlist
** test / example: storing meta-information in options for integration with eg Rails controllers, views
** Rails helpers for views etc? Tie-in to controller stuff?
** conditionals - guards & test transitions
*** needs / requires
** Persistence w/ Marshall.dump / reload ;; json / yaml ;;
   Marshal works a treat as long as you got no procs
*** useful though?
*** other formats?
**** YAML
**** JSON
**** nested hash as basic interchange format?
*** avoid procs if possible, or provide alternatives, to keep these options open
*** serialize / deserialize allows easy deep-object copies

** Documentation
*** high-level overviews
**** of the API / syntax
**** of the behind-the-scenes action and how classes relate

* requirements, etc should be (re-)orderable ?

** Machines should
*** be deep-copyable
**** store blocks passed to them in an array so that they can be replayed?
**** use a recorder pattern?
**** -> common interchange format? ie, hash / marshal.dump / yaml ?
*** cast to string / json / ... without looking like ass
*** able to generate dot / graphviz

* Specs pending

* Code smells
** specs

* Other
** testing w/ heckle, rcov
** benchmark / tune for performance

==
DONE
* Contexts
** should be extensible by the user to create a custom DSL
*** how to work this into the DSL? Scope?
* DONE add before_create :state_fu! for active_record
* implement simple deep cloning

    class Object
      def dclone
        case self
          when Fixnum,Bignum,Float,NilClass,FalseClass,
               TrueClass,Continuation
            klone = self
          when Hash
            klone = self.clone
            self.each{|k,v| klone[k] = v.dclone}
          when Array
            klone = self.clone
            klone.clear
            self.each{|v| klone << v.dclone}
          else
            klone = self.clone
        end
        klone.instance_variables.each {|v|
          klone.instance_variable_set(v,
            klone.instance_variable_get(v).dclone)
        }
        klone
      end
    end
